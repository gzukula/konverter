package konverter.processor

import com.squareup.kotlinpoet.ClassName
import com.squareup.kotlinpoet.FileSpec
import com.squareup.kotlinpoet.FunSpec
import com.squareup.kotlinpoet.KModifier
import com.squareup.kotlinpoet.PropertySpec
import com.squareup.kotlinpoet.TypeSpec
import com.squareup.kotlinpoet.asTypeName
import konverter.Konvertable
import konverter.domain.KonvertResolvedInfo
import konverter.helper.elementUtils
import konverter.helper.filer
import konverter.helper.info
import konverter.helper.isType
import konverter.resovler.PoetResolver
import javax.annotation.processing.AbstractProcessor
import javax.annotation.processing.RoundEnvironment
import javax.annotation.processing.SupportedAnnotationTypes
import javax.annotation.processing.SupportedSourceVersion
import javax.lang.model.SourceVersion
import javax.lang.model.element.ElementKind
import javax.lang.model.element.PackageElement
import javax.lang.model.element.TypeElement
import javax.lang.model.element.VariableElement

@SupportedSourceVersion(SourceVersion.RELEASE_8)
@SupportedAnnotationTypes("konverter.Konvertable")
class KonvertableProcessor : AbstractProcessor() {

    override fun process(
        annotations: MutableSet<out TypeElement>,
        roundEnv: RoundEnvironment
    ): Boolean {
        info { "annotations: $annotations" }
        if (annotations.isEmpty()) return true

        if (roundEnv.processingOver()) {
            info { "processing over" }
            // TODO generate code
        }

        info { "processing: ${annotations.first()}" }

        // 1. find and filter elements related to the annotation processed
        val elements = roundEnv.getElementsAnnotatedWith(annotations.first())
            .also { info { "before filter: $it" } }
            .filter { it.kind == ElementKind.CLASS }
            .filterIsInstance<TypeElement>()
        if (elements.isEmpty()) {
            return true
        }

        info { "elements: $elements" }

        val packageElement: PackageElement = elementUtils.getPackageOf(elements.first())
        val fileName = "konvertable-generated"
        val packageName = packageElement.toString()

        val fileBuilder = FileSpec.builder(packageName, fileName)

        elements.forEach { element ->

            val members = element.enclosedElements
                .filter { it.kind == ElementKind.FIELD }
                .filterIsInstance<VariableElement>()

            info { "KonvertableProcessor: $members" }

            val konvertable = element.getAnnotation(Konvertable::class.java)
            konvertable.classes.forEach {
                val pick = it.pick
                val omit = it.omit
                val resolvedMembers = members.run {
                    var list = this
                    if (pick.isNotEmpty()) {
                        list = list.filter { it.simpleName.toString() in pick }
                    }
                    if (omit.isNotEmpty()) {
                        list = list.filterNot { it.simpleName.toString() in omit }
                    }
                    // TODO add friendly comment for confusion omit and pick
                    list
                }
                val toClassName = it.name
                val classBuilder = TypeSpec.classBuilder(toClassName)
                    .addKdoc("Generated by @Konvertable")
                    .addModifiers(KModifier.DATA)

                val constructor = FunSpec.constructorBuilder()
                resolvedMembers.forEach {
                    val type = it.asType()
                    val kotlinType = if (type.isType<String>()) String::class.asTypeName() else type.asTypeName()
                    constructor.addParameter(
                        name = it.simpleName.toString(),
                        type = kotlinType
                    )
                    classBuilder.addProperty(
                        PropertySpec.builder(
                            name = it.simpleName.toString(),
                            type = kotlinType
                        ).initializer(it.simpleName.toString()).build()
                    )
                }

                classBuilder.primaryConstructor(constructor.build())
                fileBuilder.addType(classBuilder.build())

                // build map for @Konvert
                val resolved = resolvedMembers.associateWith {
                    KonvertResolvedInfo(
                        origin = it,
                        expression = it.simpleName.toString()
                    )
                }

                val poet = PoetResolver.buildFunction(
                    toClassName = toClassName,
                    fromType = element.asType().asTypeName(),
                    toType = ClassName.bestGuess("$packageName.$toClassName"),
                    map = resolved
                )
                fileBuilder.addFunction(poet.funSpec)
            }
        }

        fileBuilder.build().writeTo(filer)

        return true
    }
}