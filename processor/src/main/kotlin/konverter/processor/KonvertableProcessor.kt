package konverter.processor

import com.squareup.kotlinpoet.ClassName
import com.squareup.kotlinpoet.FileSpec
import com.squareup.kotlinpoet.FunSpec
import com.squareup.kotlinpoet.KModifier
import com.squareup.kotlinpoet.PropertySpec
import com.squareup.kotlinpoet.TypeSpec
import com.squareup.kotlinpoet.asTypeName
import konverter.Konvertable
import konverter.domain.KonvertResolvedInfo
import konverter.helper.elementUtils
import konverter.helper.filer
import konverter.helper.info
import konverter.helper.isType
import konverter.resovler.PoetResolver
import javax.annotation.processing.AbstractProcessor
import javax.annotation.processing.RoundEnvironment
import javax.annotation.processing.SupportedAnnotationTypes
import javax.annotation.processing.SupportedSourceVersion
import javax.lang.model.SourceVersion
import javax.lang.model.element.ElementKind
import javax.lang.model.element.PackageElement
import javax.lang.model.element.TypeElement
import javax.lang.model.element.VariableElement

@SupportedSourceVersion(SourceVersion.RELEASE_8)
@SupportedAnnotationTypes("konverter.Konvertable")
class KonvertableProcessor : AbstractProcessor() {

    override fun process(
        annotations: MutableSet<out TypeElement>,
        roundEnv: RoundEnvironment
    ): Boolean {
        if (annotations.isEmpty()) return true

        // 1. find and filter elements related to the annotation processed
        val elements = roundEnv.getElementsAnnotatedWith(Konvertable::class.java)
            .filter { it.kind == ElementKind.CLASS }
            .filterIsInstance<TypeElement>()
        if (elements.isEmpty()) {
            return true
        }

        val packageElement: PackageElement = elementUtils.getPackageOf(elements.first())
        val fileName = "konvertable-generated"
        val packageName = packageElement.toString()

        val fileBuilder = FileSpec.builder(packageName, fileName)

        elements.forEach { element ->

            val members = element.enclosedElements
                .filter { it.kind == ElementKind.FIELD }
                .filterIsInstance<VariableElement>()

            info { "KonvertableProcessor: $members" }

            val konvertable = element.getAnnotation(Konvertable::class.java)
            val pick = konvertable.pick
            val omit = konvertable.omit
            val resolvedMembers = members.run {
                var list = this
                if (pick.isNotEmpty()) {
                    list = list.filter { it.simpleName.toString() in pick }
                }
                if (omit.isNotEmpty()) {
                    list = list.filterNot { it.simpleName.toString() in omit }
                }
                // TODO add friendly comment for confusion omit and pick
                list
            }

            val toClassName = konvertable.name
            val classBuilder = TypeSpec.classBuilder(toClassName)
                .addKdoc("Generated by @Konvertable")
                .addModifiers(KModifier.DATA)

            val constructor = FunSpec.constructorBuilder()
            resolvedMembers.forEach {
                val type = it.asType()
                val kotlinType = if (type.isType<String>()) String::class.asTypeName() else type.asTypeName()
                constructor.addParameter(
                    name = it.simpleName.toString(),
                    type = kotlinType
                )
                classBuilder.addProperty(
                    PropertySpec.builder(
                        name = it.simpleName.toString(),
                        type = kotlinType
                    ).initializer(it.simpleName.toString()).build()
                )
            }

            classBuilder.primaryConstructor(constructor.build())
            fileBuilder.addType(classBuilder.build())

            // build map for @Konvert
            val resolved = resolvedMembers.associateWith {
                KonvertResolvedInfo(
                    origin = it,
                    expression = it.simpleName.toString()
                )
            }

            val konvertPoet = PoetResolver.buildFunction(
                toClassName = toClassName,
                fromType = element.asType().asTypeName(),
                toType = ClassName.bestGuess("$packageName.$toClassName"),
                map = resolved
            )
            fileBuilder.addFunction(konvertPoet.funSpec)
        }

        fileBuilder.build().writeTo(filer)

        return true
    }
}